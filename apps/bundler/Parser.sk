module Parser;

// The result of parsing a source file
class ParserResult{
  // Possibly empty list of file paths extracted from `require('<path>')` statements
  requires: Vector<String>,
  // The text following the last require() statement
  remainingText: String,
}

// Parses text to extract require() dependencies, returning a ParserResult.
fun parse(text: String): ParserResult {
  Parser::new(text).getRequires();
}

fun dbg(t: String): void {
    debug(t);
}

fun dbgchar(c: ?Char): void {
    c match {
        |None() -> debug("**NaC**");
        |Some(char) -> debug(String::fromChars(Array[char]));
    }
}

// Private parser class for demonstration purposes - a production version would
// need a more robust parser.
private mutable class Parser private (
  text: String,
  current: mutable String.StringIterator,
  mutable lengthSoFar: Int,
  mutable lastRequire: String.StringIterator,
  requires: mutable Vector<String>,
) {
  static fun new(text: String): mutable this {
    current = String.StringIterator::make(text);
    dbg("new parser! ");
    dbg(text.sub(current, 10));
    dbg("...");
    mutable static(
        text,
        current,
        0,
        freeze(current),
        mutable Vector[]
    )
  }

  mutable fun getRequires(): ParserResult {
    this.parse();
    remainingText = this.text.sub(
      this.lastRequire,
      this.text.length() - this.lengthSoFar,
    );
    dbg("getRequires: ");
    dbg(remainingText);
    ParserResult{requires => freeze(this.requires), remainingText}
  }

  private mutable fun next(): (String.StringIterator, ?Char) {
    dbg("next() {");
    before = freeze(this.current);
    c = this.current.next();
    dbg(this.lengthSoFar.toString());
    dbg("returning substr: " + this.text.sub(before, 1) + "...");
    dbg("next() } ");

    this.!lengthSoFar = this.lengthSoFar + 1;
    (before, c);
  }

  private mutable fun parse(): void {
    (_, char) = this.next();
    char match {
    | None() -> void
    | Some('r') ->
      startPos = this.lengthSoFar;
      first = this.current;
      this.parseKeyword();
      len = this.lengthSoFar - startPos;
      s = this.text.sub(first, len);
      if (s == "require") {
        dbg("parse: -->");
        dbg(s);
        filename = this.parseRequire();
        this.requires.push(filename);
      };
      this.parse()
    | _ -> this.parse()
    };
  }

  private mutable fun parseKeyword(): void {
          (_, char) = this.next();
          char match {
          | Some(x) if (x >= 'a' && x <= 'z' || x >= 'A' && x <= 'Z') -> void
          | _ -> this.parseKeyword()
          }
  }

  private mutable fun parseRequire(): String {
    char: ?Char = Some('0');
    while (char != None() && char != Some('\'')) {
      (_, !char) = this.next()
    };
    (first, !char) = this.next();
    last = first;
    span = 0;
    while (char != None() && char != Some('\'')) {
      !span = span + 1;
      (!last, !char) = this.next()
    };
    result = this.text.sub(first, span);
    while (char != None() && char != Some('\n')) {
      (!last, !char) = this.next()
    };
    this.!lastRequire = last;
    result
  }
}

module end;
